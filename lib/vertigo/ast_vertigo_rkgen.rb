# ============================================================
# This code was generated by rkgen utility.
# DO NOT MODIFY !
# ============================================================
 
module Vertigo
 
  class AstNode
    def accept(visitor, arg=nil)
       name = self.class.name.split(/::/).last
       visitor.send("visit#{name}".to_sym, self ,arg) # Metaprograming !
    end

    def str
      ppr=PrettyPrinter.new
      self.accept(ppr)
    end
  end
   
  class Root < AstNode
    attr_accessor :design_units
    def initialize design_units=[]
      @design_units=design_units
    end
  end
   
  class Library < AstNode
    attr_accessor :name
    def initialize name=nil
      @name=name
    end
  end
   
  class Use < AstNode
    attr_accessor :library,:package,:element
    def initialize library=nil,package=nil,element=nil
      @library,@package,@element=library,package,element
    end
  end
   
  class Entity < AstNode
    attr_accessor :name,:generics,:ports
    def initialize name=nil,generics=[],ports=[]
      @name,@generics,@ports=name,generics,ports
    end
  end
   
  class Generic < AstNode
    attr_accessor :name,:type,:init
    def initialize name=nil,type=nil,init=nil
      @name,@type,@init=name,type,init
    end
  end
   
  class Input < AstNode
    attr_accessor :name,:type,:init
    def initialize name=nil,type=nil,init=nil
      @name,@type,@init=name,type,init
    end
  end
   
  class Output < AstNode
    attr_accessor :name,:type,:init
    def initialize name=nil,type=nil,init=nil
      @name,@type,@init=name,type,init
    end
  end
   
  class InOut < AstNode
    attr_accessor :name,:type,:init
    def initialize name=nil,type=nil,init=nil
      @name,@type,@init=name,type,init
    end
  end
   
  class Architecture < AstNode
    attr_accessor :name,:entity_name,:decls,:body
    def initialize name=nil,entity_name=nil,decls=[],body=nil
      @name,@entity_name,@decls,@body=name,entity_name,decls,body
    end
  end
   
  class Body < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class Process < AstNode
    attr_accessor :sensitivity,:decls,:body
    def initialize sensitivity=nil,decls=[],body=nil
      @sensitivity,@decls,@body=sensitivity,decls,body
    end
  end
   
  class Sensitivity < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class EntityInstance < AstNode
    attr_accessor :full_name,:arch_name,:generic_map,:port_map
    def initialize full_name=nil,arch_name=nil,generic_map=nil,port_map=nil
      @full_name,@arch_name,@generic_map,@port_map=full_name,arch_name,generic_map,port_map
    end
  end
   
  class PortMap < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class Map < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class SigAssign < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class VarAssign < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class Wait < AstNode
    attr_accessor :until_,:for_
    def initialize until_=nil,for_=nil
      @until_,@for_=until_,for_
    end
  end
   
  class If < AstNode
    attr_accessor :cond,:body,:elsifs,:else_
    def initialize cond=nil,body=nil,elsifs=[],else_=nil
      @cond,@body,@elsifs,@else_=cond,body,elsifs,else_
    end
  end
   
  class Elsif < AstNode
    attr_accessor :cond,:body
    def initialize cond=nil,body=nil
      @cond,@body=cond,body
    end
  end
   
  class Else < AstNode
    attr_accessor :body
    def initialize body=nil
      @body=body
    end
  end
   
  class Case < AstNode
    attr_accessor :expr,:whens
    def initialize expr=nil,whens=[]
      @expr,@whens=expr,whens
    end
  end
   
  class CaseWhen < AstNode
    attr_accessor :expr,:body
    def initialize expr=nil,body=nil
      @expr,@body=expr,body
    end
  end
   
  class NullStmt < AstNode
    attr_accessor :dummy
    def initialize dummy=nil
      @dummy=dummy
    end
  end
   
  class TypeDecl < AstNode
    attr_accessor :name,:spec
    def initialize name=nil,spec=nil
      @name,@spec=name,spec
    end
  end
   
  class Enum < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class Record < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class RecordItem < AstNode
    attr_accessor :name,:type
    def initialize name=nil,type=nil
      @name,@type=name,type
    end
  end
   
  class Constant < AstNode
    attr_accessor :name,:type,:expr
    def initialize name=nil,type=nil,expr=nil
      @name,@type,@expr=name,type,expr
    end
  end
   
  class Signal < AstNode
    attr_accessor :name,:type,:init
    def initialize name=nil,type=nil,init=nil
      @name,@type,@init=name,type,init
    end
  end
   
  class StdType < AstNode
    attr_accessor :ident
    def initialize ident=nil
      @ident=ident
    end
  end
   
  class NamedType < AstNode
    attr_accessor :ident
    def initialize ident=nil
      @ident=ident
    end
  end
   
  class ArrayType < AstNode
    attr_accessor :name,:discrete_ranges
    def initialize name=nil,discrete_ranges=[]
      @name,@discrete_ranges=name,discrete_ranges
    end
  end
   
  class DiscreteRange < AstNode
    attr_accessor :lhs,:dir,:rhs
    def initialize lhs=nil,dir=nil,rhs=nil
      @lhs,@dir,@rhs=lhs,dir,rhs
    end
  end
   
  class Parenth < AstNode
    attr_accessor :expr
    def initialize expr=nil
      @expr=expr
    end
  end
   
  class Waveform < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class CondExpr < AstNode
    attr_accessor :whens,:else_
    def initialize whens=[],else_=nil
      @whens,@else_=whens,else_
    end
  end
   
  class When < AstNode
    attr_accessor :expr,:cond
    def initialize expr=nil,cond=nil
      @expr,@cond=expr,cond
    end
  end
   
  class Binary < AstNode
    attr_accessor :lhs,:op,:rhs
    def initialize lhs=nil,op=nil,rhs=nil
      @lhs,@op,@rhs=lhs,op,rhs
    end
  end
   
  class After < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class Timed < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class Ident < AstNode
    attr_accessor :tok
    def initialize tok=nil
      @tok=tok
    end
  end
   
  class IntLit < AstNode
    attr_accessor :tok
    def initialize tok=nil
      @tok=tok
    end
  end
   
  class SelectedName < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
   
  class FuncCall < AstNode
    attr_accessor :name,:actual_args
    def initialize name=nil,actual_args=[]
      @name,@actual_args=name,actual_args
    end
  end
   
  class Aggregate < AstNode
    attr_accessor :elements
    def initialize elements=[]
      @elements=elements
    end
  end
   
  class Label < AstNode
    attr_accessor :ident
    def initialize ident=nil
      @ident=ident
    end
  end
   
  class Assoc < AstNode
    attr_accessor :lhs,:rhs
    def initialize lhs=nil,rhs=nil
      @lhs,@rhs=lhs,rhs
    end
  end
end # Vertigo
